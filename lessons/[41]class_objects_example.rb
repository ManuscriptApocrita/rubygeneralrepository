# В отдельном файле bridge.rb объявляем класс Bridge (Мост)
#
# Обратите внимание, название файла всегда совпадает с названием класса,
# только пишется маленькими буквами.
#
# Если в названии класса два слова: BigBridge, то в названии файла эти слова
# разделяются подчеркиванием: big_bridge.rb.
#
# Везде, где мы подключим файл bridge.rb мы сможем создавать объекты класса
# Bridge и пользоваться их методами
class Bridge
  # Специальный метод initialize в руби играет роль конструктора класса он
  # вызывается при создании объекта данного класса, когда пишем Bridge.new.
  def initialize
    # В нашем конструкторе мы для наглядности напишем, что мост создан
    puts 'Мост создан'

    # И создадим переменную экземпляра класса @opened. Обратите внимание, что
    # переменные экземпляра объявляются и используются только в методах класса.
    # Перед их названием стоит символ @.
    #
    # Все необходимые поля класса, которые объект класса будет использовать в
    # своих методах нужно объявлять и задавать в конструкторе, присваивая им
    # их начальные значения.
    #
    # Начальное значение переменной @opened у нас будет false.
    @opened = false
  end

  # Объявим метод open свой метод, который будет открывать наш мост
  def open
    # Меняем состояние объекта (а конкретно, переменной @opened)
    @opened = true

    # Для наглядности сообщаем об этом в консоль
    puts 'Мост открыт, можно ехать'
  end

  # Объявляем метод close, который будет закрывать мост
  def close
    # Меняем состояние объекта (а конкретно, переменной @opened)
    @opened = false

    # Для наглядности сообщаем об этом в консоль
    puts 'Мост закрыт'
  end

  # Объявим метод is_opened? который будет возвращать true, если мост открыт
  # и false, если закрыт. По соглашению, на конце методов, которые возвращают
  # true или false должен быть знак вопроса.
  def is_opened?
    return @opened
  end
end

####

# encoding: utf-8

# Подключаем класс Bridge из файла bridge.rb
require './bridge.rb'

puts 'Start'
sleep 1

puts 'Первый километр'
sleep 1

puts 'Ой! Река! Нужно перекинуть мост…'
sleep 2

# Специальный метод .new — создает объект выбранного класса. В нашем случае
# в переменной bridge будет объект класса Bridge.
bridge = Bridge.new

sleep 1

# Обратите внимание!
#
# Эта строчка выдала бы ошибку. Методы экземпляра можно вызывать только у
# конкретного объекта данного класса, а не у самого класса.
# Bridge.open

# Используем написанный нами функционал открыания моста. Проверяем состояние
# моста, открываем, если он не открыт (напомним, что ! в условии означает
# отрицание !true — это false).
if !bridge.is_opened?
  # Если мост закрыт, открываем его
  bridge.open
end
sleep 1

# Еще раз проверяем состояние моста, уже после открытия
if !bridge.is_opened?
  # Если мост все ещё не удалось открыть — аварийно завершаем программу
  abort 'мост не удалось открыть!'
end

puts 'Проехали мост'
sleep 2

# Мост проехали, можно закрывать за собой
bridge.close

sleep 1

puts 'Второй километр'
sleep 1

puts 'Третий километр'
sleep 1

puts 'Finish!'